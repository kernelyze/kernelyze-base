! worst_rho_and_gamma.f90
!
! Copyright (c) 2016, 2017 by Kernelyze LLC
! Author: Thomas A. Knox
! This program is free software: you can redistribute it and/or modify
! it under the terms of the GNU Affero General Public License as
! published by the Free Software Foundation, either version 3 of the
! License, or (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU Affero General Public License for more details.
! 
! You should have received a copy of the GNU Affero General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.
!
! created on: 2016-07-01
! updated on: 2016-07-01
! updated on: 2016-07-02 (continued work toward compilation)
! updated on: 2016-07-03 (fixed some comments and fixed issue
!             with matrix for remez_variant calls -- can now
!             pass it in, as is necessary here)
! updated on: 2017-04-23 (remove use of kernel_remez module,
!             whose functionality is no longer accessed here)
!
! A module containing the subroutine worst_rho_for_kernel_general.
! This module uses an iterative process to maximize the lower bound 
! generated by the subroutine borsuk_lower_bound over the vector 
! $\rho$ (of y values) and the vector $\gamma$ (of x values), thus
! providing a "worst rho" (and "worst_gamma") for the given kernel.
! The key idea is to find the x values that generate the maximal
! errors in the Borsuk procedure when $\rho$ defines a set of kernel
! sections by substitution into the y argument, and use these nodes
! as the vector $\gamma$ in forming kernel sections by substitution
! into the x argument -- the Borsuk procedure applied to these
! $\gamma$ sections then gives nodes that can be used as the $\rho$
! vector in the next iteration, and so on.
!
! NOTE that the kernel $K \left( x , y \right) $ must be
! nondegenerate totally positive on the rectangle
! $\left[x_L , x_U \right] \times \left[ y_L , y_U \right]$
! to use the subroutine worst_rho_and_gamma.
  
module worst_rho_and_gamma_mod
  use set_precision, only : wp
  use constants_mod, only : err_msg_len
  use chebyshev_points_mod, only : chebyshev_points
  use compute_a_and_b_matrices_mod, only : compute_a_and_b_matrices
  use quicksort, only : qsort
  use borsuk_lower_bound_mod, only : borsuk_lower_bound
  use remez_variant_mod, only : remez_variant
  use kernel_mod, only : kernel
  use, intrinsic :: ieee_arithmetic, only : &
      ieee_value, ieee_quiet_nan, ieee_positive_inf
  implicit none
  contains
  subroutine worst_rho_and_gamma( &
      kernel_obj, &
      num_terms, & 
      tolerance, &
      max_iter, &
      rho_vec, &
      gamma_vec, &
      coeffs_rho, &
      coeffs_gamma, &
      a_matrix_rho, &
      a_matrix_gamma, &
      nodes_rho, &
      nodes_gamma, &
      errors_at_nodes_rho, &
      errors_at_nodes_gamma, &
      b_coeffs_rho, &
      b_coeffs_gamma, &
      b_nodes_rho, &
      b_nodes_gamma, &
      b_errors_at_nodes_rho, &
      b_errors_at_nodes_gamma, &
      discrepancy, &
      num_iter, &
      ker_discrep, &
      ker_num_iter, &
      err_stat, &
      err_msg)
    ! Arguments
    class(kernel), intent(in)                   :: kernel_obj
    integer, intent(in)                         :: num_terms
    real(wp), intent(in)                        :: tolerance
    integer, intent(in)                         :: max_iter
    real(wp), intent(out), dimension(num_terms) :: rho_vec
    real(wp), intent(out), dimension(num_terms) :: gamma_vec
    real(wp), intent(out), dimension(num_terms) :: coeffs_rho
    real(wp), intent(out), dimension(num_terms) :: coeffs_gamma
    real(wp), intent(out), &
        dimension(num_terms, num_terms)         :: a_matrix_rho
    real(wp), intent(out), &
        dimension(num_terms, num_terms)         :: a_matrix_gamma
    real(wp), intent(out), dimension(num_terms) :: nodes_rho
    real(wp), intent(out), dimension(num_terms) :: nodes_gamma
    real(wp), intent(out), dimension(num_terms) :: errors_at_nodes_rho
    real(wp), intent(out), dimension(num_terms) :: errors_at_nodes_gamma
    real(wp), intent(out), dimension(num_terms) :: b_coeffs_rho
    real(wp), intent(out), dimension(num_terms) :: b_coeffs_gamma
    real(wp), intent(out), dimension(num_terms) :: b_nodes_rho
    real(wp), intent(out), dimension(num_terms) :: b_nodes_gamma
    real(wp), intent(out), dimension(num_terms) :: b_errors_at_nodes_rho
    real(wp), intent(out), dimension(num_terms) :: b_errors_at_nodes_gamma
    real(wp), intent(out)                       :: discrepancy
    integer, intent(out)                        :: num_iter
    real(wp), intent(out)                       :: ker_discrep
    integer, intent(out)                        :: ker_num_iter
    ! Optional arguments to pass back information on any errors
    integer, intent(out), optional                    :: err_stat
    character(len=err_msg_len), intent(out), optional :: err_msg
    ! Local variables
    real(wp)                        :: b_discrepancy_rho
    real(wp)                        :: b_discrepancy_gamma
    real(wp)                        :: k_discrepancy_rho
    real(wp)                        :: k_discrepancy_gamma
    real(wp)                        :: minval_b_error_at_rho
    real(wp)                        :: minval_b_error_at_gamma
    real(wp)                        :: ker_error
    real(wp)                        :: new_ker_error
    real(wp)                        :: temp_saved_val
    real(wp), dimension(num_terms)  :: temp_b_nodes_rho
    real(wp), dimension(num_terms)  :: temp_b_nodes_gamma
    integer                         :: b_num_iter
    integer                         :: k_num_iter
    ! Local variables to handle any problems:
    character(*), parameter         :: proc_name = &
        "Worst rho and gamma for kernel: "
    ! Local variables to handle information on any local errors
    integer                         :: local_err_stat
    character(len=err_msg_len)      :: local_err_msg
    ! Body
    ! Initialize the optional error arguments if present
    if (present(err_stat)) then
      err_stat = 0
    end if
    if (present(err_msg)) then
      err_msg = ''
    end if
    ! A decent initial guess is the Chebyshev points
    rho_vec = kernel_obj%cheb_pts(.false. , num_terms)
    gamma_vec = kernel_obj%cheb_pts(.true. , num_terms)
    ! Note that the optional argument "grid" is not supplied in this call,
    ! which is for optimization over x with each rho_vec element being
    ! applied to the kernel's y argument to create a kernel section
    call borsuk_lower_bound( &
        kernel_obj = kernel_obj, &
        rho_vec = rho_vec , &
        is_over_x = .true. , &
        tolerance = tolerance , &
        max_iter = max_iter , &
        coeffs = b_coeffs_rho , &
        nodes = b_nodes_rho , &
        errors_at_nodes = b_errors_at_nodes_rho , &
        discrepancy = b_discrepancy_rho , &
        num_iter = b_num_iter , &
        err_stat = local_err_stat , &
        err_msg = local_err_msg)
    if (local_err_stat /= 0) then
      ! This means that the Borsuk lower bound calculation did not go well.
      ! If err_stat and / or err_msg were provided, fill them in
      if (present(err_stat)) then
        err_stat = local_err_stat
      end if
      if (present(err_msg)) then
        err_msg = proc_name // local_err_msg
      end if
      ! Set the intent(out) variables to quiet NaNs
      rho_vec = ieee_value(rho_vec, ieee_quiet_nan)
      gamma_vec = ieee_value(gamma_vec, ieee_quiet_nan)
      coeffs_rho = ieee_value(coeffs_rho, ieee_quiet_nan)
      coeffs_gamma = ieee_value(coeffs_gamma, ieee_quiet_nan)
      a_matrix_rho = ieee_value(a_matrix_rho, ieee_quiet_nan)
      a_matrix_gamma = ieee_value(a_matrix_gamma, ieee_quiet_nan)
      ! Return
      return
    end if
    coeffs_rho = b_coeffs_rho
    nodes_rho = b_nodes_rho
    errors_at_nodes_rho = b_errors_at_nodes_rho
    ! Note that the optional argument "grid" is not supplied in this call,
    ! which is for optimization over y with each gamma_vec element being
    ! applied to the kernel's x argument to create a kernel section
    call borsuk_lower_bound( &
        kernel_obj = kernel_obj, &
        rho_vec = gamma_vec , &
        is_over_x = .false. , &
        tolerance = tolerance , &
        max_iter = max_iter , &
        coeffs = b_coeffs_gamma , &
        nodes = b_nodes_gamma , &
        errors_at_nodes = b_errors_at_nodes_gamma , &
        discrepancy = b_discrepancy_gamma , &
        num_iter = b_num_iter , &
        err_stat = local_err_stat , &
        err_msg = local_err_msg)
    if (local_err_stat /= 0) then
      ! This means that the Borsuk lower bound calculation did not go well.
      ! If err_stat and / or err_msg were provided, fill them in
      if (present(err_stat)) then
        err_stat = local_err_stat
      end if
      if (present(err_msg)) then
        err_msg = proc_name // local_err_msg
      end if
      ! Set the intent(out) variables to quiet NaNs
      rho_vec = ieee_value(rho_vec, ieee_quiet_nan)
      gamma_vec = ieee_value(gamma_vec, ieee_quiet_nan)
      coeffs_rho = ieee_value(coeffs_rho, ieee_quiet_nan)
      coeffs_gamma = ieee_value(coeffs_gamma, ieee_quiet_nan)
      a_matrix_rho = ieee_value(a_matrix_rho, ieee_quiet_nan)
      a_matrix_gamma = ieee_value(a_matrix_gamma, ieee_quiet_nan)
      ! Return
      return
    end if
    coeffs_gamma = b_coeffs_gamma
    nodes_gamma = b_nodes_gamma
    errors_at_nodes_gamma = b_errors_at_nodes_gamma
    ! Loop to find the rho_vec and gamma_vec that maximize the
    ! x-direction and the y-direction Borsuk lower bounds (these
    ! two bounds will be equal at the optimum).
    ! Note that the iterative idea of is to set rho to the
    ! vector of y-coordinates of relative arg-optima from
    ! the gamma optimization and setting gamma to the vector of
    ! x-coordinates of the relative arg-optima from the rho
    ! optimization.
    discrepancy = tolerance + 1.0E0_wp
    num_iter = 0
    do while (discrepancy > tolerance .and. num_iter <= max_iter)
      ! Make sure that the b_nodes_gamma are ordered
      call qsort(b_nodes_gamma, 1, num_terms, temp_saved_val)
      ! Get the new rho_vec
      rho_vec = b_nodes_gamma
      ! Note that the optional argument "grid" is not supplied in this call
      call borsuk_lower_bound( &
          kernel_obj = kernel_obj, &
          rho_vec = rho_vec, &
          is_over_x = .true., &
          tolerance = tolerance, &
          max_iter = max_iter, &
          coeffs = b_coeffs_rho, &
          nodes = b_nodes_rho, &
          errors_at_nodes = b_errors_at_nodes_rho, &
          discrepancy = b_discrepancy_rho, &
          num_iter = b_num_iter, &
          err_stat = local_err_stat, &
          err_msg = local_err_msg)
      if (local_err_stat /= 0) then
        ! This means that the Borsuk lower bound calculation did not go well.
        ! If err_stat and / or err_msg were provided, fill them in
        if (present(err_stat)) then
          err_stat = local_err_stat
        end if
        if (present(err_msg)) then
          err_msg = proc_name // local_err_msg
        end if
        ! Set the intent(out) variables to quiet NaNs
        rho_vec = ieee_value(rho_vec, ieee_quiet_nan)
        gamma_vec = ieee_value(gamma_vec, ieee_quiet_nan)
        coeffs_rho = ieee_value(coeffs_rho, ieee_quiet_nan)
        coeffs_gamma = ieee_value(coeffs_gamma, ieee_quiet_nan)
        a_matrix_rho = ieee_value(a_matrix_rho, ieee_quiet_nan)
        a_matrix_gamma = ieee_value(a_matrix_gamma, ieee_quiet_nan)
        ! Return
        return
      end if
      ! Make sure the b_nodes_rho are ordered
      call qsort(b_nodes_rho, 1, num_terms, temp_saved_val)
      ! Get the new gamma_vec
      gamma_vec = b_nodes_rho
      ! Note that the optional argument "grid" is not supplied in this call
      call borsuk_lower_bound( &
          kernel_obj = kernel_obj, &
          rho_vec = gamma_vec, &
          is_over_x = .false., &
          tolerance = tolerance, &
          max_iter = max_iter, &
          coeffs = b_coeffs_gamma, &
          nodes = b_nodes_gamma, &
          errors_at_nodes = b_errors_at_nodes_gamma, &
          discrepancy = b_discrepancy_gamma, &
          num_iter = b_num_iter, &
          err_stat = local_err_stat, &
          err_msg = local_err_msg)
      if (local_err_stat /= 0) then
        ! This means that the Borsuk lower bound calculation did not go well.
        ! If err_stat and / or err_msg were provided, fill them in
        if (present(err_stat)) then
          err_stat = local_err_stat
        end if
        if (present(err_msg)) then
          err_msg = proc_name // local_err_msg
        end if
        ! Set the intent(out) variables to quiet NaNs
        rho_vec = ieee_value(rho_vec, ieee_quiet_nan)
        gamma_vec = ieee_value(gamma_vec, ieee_quiet_nan)
        coeffs_rho = ieee_value(coeffs_rho, ieee_quiet_nan)
        coeffs_gamma = ieee_value(coeffs_gamma, ieee_quiet_nan)
        a_matrix_rho = ieee_value(a_matrix_rho, ieee_quiet_nan)
        a_matrix_gamma = ieee_value(a_matrix_gamma, ieee_quiet_nan)
        ! Return
        return
      end if
      ! Increment the number of iterations
      num_iter = num_iter + 1
      ! Update the discrepancy; to do this, I need to call borsuk_lower_bound
      ! one additional time.
      minval_b_error_at_rho = minval(abs(b_errors_at_nodes_rho))
      temp_b_nodes_gamma = b_nodes_gamma
      call borsuk_lower_bound( &
          kernel_obj = kernel_obj, &
          rho_vec = temp_b_nodes_gamma, &
          is_over_x = .true., &
          tolerance = tolerance, &
          max_iter = max_iter, &
          coeffs = b_coeffs_rho, &
          nodes = b_nodes_rho, &
          errors_at_nodes = b_errors_at_nodes_rho, &
          discrepancy = b_discrepancy_rho, &
          num_iter = b_num_iter, &
          err_stat = local_err_stat, &
          err_msg = local_err_msg)
      if (local_err_stat /= 0) then
        ! This means that the Borsuk lower bound calculation did not go well.
        ! If err_stat and / or err_msg were provided, fill them in
        if (present(err_stat)) then
          err_stat = local_err_stat
        end if
        if (present(err_msg)) then
          err_msg = proc_name // local_err_msg
        end if
        ! Set the intent(out) variables to quiet NaNs
        rho_vec = ieee_value(rho_vec, ieee_quiet_nan)
        gamma_vec = ieee_value(gamma_vec, ieee_quiet_nan)
        coeffs_rho = ieee_value(coeffs_rho, ieee_quiet_nan)
        coeffs_gamma = ieee_value(coeffs_gamma, ieee_quiet_nan)
        a_matrix_rho = ieee_value(a_matrix_rho, ieee_quiet_nan)
        a_matrix_gamma = ieee_value(a_matrix_gamma, ieee_quiet_nan)
        ! Return
        return
      end if
      ! Update the discrepancy; to do this, I need to call borsuk_lower_bound
      ! one additional time.
      minval_b_error_at_gamma = minval(abs(b_errors_at_nodes_gamma))
      temp_b_nodes_rho = b_nodes_rho
      call borsuk_lower_bound( &
          kernel_obj = kernel_obj, &
          rho_vec = temp_b_nodes_rho, &
          is_over_x = .false., &
          tolerance = tolerance, &
          max_iter = max_iter, &
          coeffs = b_coeffs_gamma, &
          nodes = b_nodes_gamma, &
          errors_at_nodes = b_errors_at_nodes_gamma, &
          discrepancy = b_discrepancy_gamma, &
          num_iter = b_num_iter, &
          err_stat = local_err_stat, &
          err_msg = local_err_msg)
      if (local_err_stat /= 0) then
        ! This means that the Borsuk lower bound calculation did not go well.
        ! If err_stat and / or err_msg were provided, fill them in
        if (present(err_stat)) then
          err_stat = local_err_stat
        end if
        if (present(err_msg)) then
          err_msg = proc_name // local_err_msg
        end if
        ! Set the key intent(out) variables to quiet NaNs
        rho_vec = ieee_value(rho_vec, ieee_quiet_nan)
        gamma_vec = ieee_value(gamma_vec, ieee_quiet_nan)
        coeffs_rho = ieee_value(coeffs_rho, ieee_quiet_nan)
        coeffs_gamma = ieee_value(coeffs_gamma, ieee_quiet_nan)
        a_matrix_rho = ieee_value(a_matrix_rho, ieee_quiet_nan)
        a_matrix_gamma = ieee_value(a_matrix_gamma, ieee_quiet_nan)
        ! Return
        return
      end if
      discrepancy = max( &
          minval(abs(b_errors_at_nodes_rho)) - minval_b_error_at_rho, &
          minval(abs(b_errors_at_nodes_gamma)) - minval_b_error_at_gamma )
      ! Update the output arrays
      coeffs_rho = b_coeffs_rho
      nodes_rho = b_nodes_rho
      errors_at_nodes_rho = b_errors_at_nodes_rho
      coeffs_gamma = b_coeffs_gamma
      nodes_gamma = b_nodes_gamma
      errors_at_nodes_gamma = b_errors_at_nodes_gamma
      ! If using b_nodes actually lowers the error, exit
      if (discrepancy < 0E0_wp) then
        discrepancy = 0E0_wp
        exit
      end if
    end do
    ! Did I manage to converge to within tolerance?
    if (discrepancy > tolerance) then
      ! If err_stat and / or err_msg were provided, fill them in
      if (present(err_stat)) then
        err_stat = -1
      end if
      if (present(err_msg)) then
        err_msg = proc_name // 'Maximum not achieved'
      end if
      ! Return
      return
    end if
    ! Finally, get the A and B matrices and find the relevant
    ! errors and coefficients using the kernel Remez method.
    call compute_a_and_b_matrices( &
        kernel_obj, &
        rho_vec, &
        gamma_vec, &
        a_matrix_rho, &
        a_matrix_gamma)
    ! Need to loop over Remez variants because of the joint
    ! constraint dot_product(coeffs_rho , coeffs_gamma) = 1E0_wp.
    ! Each Remez variant call can solve for either coeffs_rho
    ! given coeffs_gamma or vice versa, but iteration is required
    ! to solve for the optimal pair (coeffs_rho, coeffs_gamma).
    ! We have "guesses" from the Borsuk iteration for the coeffs, but
    ! this is clearly based on different normalization.  I at least
    ! renormalize the guesses before proceeding.
    coeffs_rho   = b_coeffs_rho   / dot_product(b_coeffs_rho , b_coeffs_gamma)
    coeffs_gamma = b_coeffs_gamma / dot_product(b_coeffs_rho , b_coeffs_gamma)
    ker_error = ieee_value(ker_error, ieee_positive_inf)
    ker_discrep = tolerance + 1.0E0_wp
    ker_num_iter = 0
    do while (ker_discrep > tolerance .and. ker_num_iter <= max_iter)
      ! First solve for the coefficients in the kernel Remez problem
      ! with minimization over x
      call remez_variant( &
          is_borsuk = .false., &
          kernel_obj = kernel_obj, &
          is_over_x = .true., &
          rho_vec = rho_vec, &
          tolerance = tolerance, &
          max_iter = max_iter, &
          vec_for_dot_prod = coeffs_gamma, & ! Expresses joint constraint
          key_matrix = a_matrix_rho, &
          coeffs = coeffs_rho, &
          nodes = nodes_rho, &
          errors_at_nodes = errors_at_nodes_rho, &
          discrepancy = k_discrepancy_rho, &
          num_iter = k_num_iter, &
          err_stat = local_err_stat, &
          err_msg = local_err_msg)
      if (local_err_stat /= 0) then
        ! This means that the kernel Remez calculation did not go well.
        ! If err_stat and / or err_msg were provided, fill them in
        if (present(err_stat)) then
          err_stat = local_err_stat
        end if
        if (present(err_msg)) then
          err_msg = proc_name // local_err_msg
        end if
        ! Set the key intent(out) variables to quiet NaNs
        rho_vec = ieee_value(rho_vec, ieee_quiet_nan)
        gamma_vec = ieee_value(gamma_vec, ieee_quiet_nan)
        coeffs_rho = ieee_value(coeffs_rho, ieee_quiet_nan)
        coeffs_gamma = ieee_value(coeffs_gamma, ieee_quiet_nan)
        a_matrix_rho = ieee_value(a_matrix_rho, ieee_quiet_nan)
        a_matrix_gamma = ieee_value(a_matrix_gamma, ieee_quiet_nan)
        ! Return
        return
      end if
      ! Now solve for the coefficients in the kernel Remez problem
      ! with minimization over y
      call remez_variant( &
          is_borsuk = .false., &
          kernel_obj = kernel_obj, &
          is_over_x = .false., &
          rho_vec = gamma_vec, &
          tolerance = tolerance, &
          max_iter = max_iter, &
          vec_for_dot_prod = coeffs_rho, & ! Expresses joint constraint
          key_matrix = a_matrix_gamma, &
          coeffs = coeffs_gamma, &
          nodes = nodes_gamma, &
          errors_at_nodes = errors_at_nodes_gamma, &
          discrepancy = k_discrepancy_gamma, &
          num_iter = k_num_iter, &
          err_stat = local_err_stat, &
          err_msg = local_err_msg)
      if (local_err_stat /= 0) then
        ! This means that the kernel Remez calculation did not go well.
        ! If err_stat and / or err_msg were provided, fill them in
        if (present(err_stat)) then
          err_stat = local_err_stat
        end if
        if (present(err_msg)) then
          err_msg = proc_name // local_err_msg
        end if
        ! Set the key intent(out) variables to quiet NaNs
        rho_vec = ieee_value(rho_vec, ieee_quiet_nan)
        gamma_vec = ieee_value(gamma_vec, ieee_quiet_nan)
        coeffs_rho = ieee_value(coeffs_rho, ieee_quiet_nan)
        coeffs_gamma = ieee_value(coeffs_gamma, ieee_quiet_nan)
        a_matrix_rho = ieee_value(a_matrix_rho, ieee_quiet_nan)
        a_matrix_gamma = ieee_value(a_matrix_gamma, ieee_quiet_nan)
        ! Return
        return
      end if
      ! Increment the number of iterations
      ker_num_iter = ker_num_iter + 1
      ! Update the discrepancy
      new_ker_error = ( minval( abs(errors_at_nodes_rho) ) * &
                        minval( abs(errors_at_nodes_gamma) ) )
      ker_discrep = ker_error - new_ker_error
      ! Update the current error level
      ker_error = new_ker_error
    end do
    ! Did I manage to converge to within tolerance?
    if (ker_discrep > tolerance) then
      ! If err_stat and / or err_msg were provided, fill them in
      if (present(err_stat)) then
        err_stat = -2
      end if
      if (present(err_msg)) then
        err_msg = proc_name // 'Kernel Remez maximum not achieved'
      end if
      ! Return
      return
    end if
  end subroutine worst_rho_and_gamma

end module worst_rho_and_gamma_mod